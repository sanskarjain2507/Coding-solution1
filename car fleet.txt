/*
 * @lc app=leetcode id=853 lang=cpp
 *
 * [853] Car Fleet
 *
 * https://leetcode.com/problems/car-fleet/description/
 *
 * algorithms
 * Medium (47.58%)
 * Likes:    1404
 * Dislikes: 412
 * Total Accepted:    81.4K
 * Total Submissions: 168.6K
 * Testcase Example:  '12\n[10,8,0,5,3]\n[2,4,1,1,3]'
 *
 * There are n cars going to the same destination along a one-lane road. The
 * destination is target miles away.
 * 
 * You are given two integer array position and speed, both of length n, where
 * position[i] is the position of the i^th car and speed[i] is the speed of the
 * i^th car (in miles per hour).
 * 
 * A car can never pass another car ahead of it, but it can catch up to itÂ and
 * drive bumper to bumper at the same speed. The faster car will slow down to
 * match the slower car's speed. The distance between these two cars is ignored
 * (i.e., they are assumed to have the same position).
 * 
 * A car fleet is some non-empty set of cars driving at the same position and
 * same speed. Note that a single car is also a car fleet.
 * 
 * If a car catches up to a car fleet right at the destination point, it will
 * still be considered as one car fleet.
 * 
 * Return the number of car fleets that will arrive at the destination.
 * 
 * 
 * Example 1:
 * 
 * 
 * Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
 * Output: 3
 * Explanation:
 * The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting
 * each other at 12.
 * The car starting at 0 does not catch up to any other car, so it is a fleet
 * by itself.
 * The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting
 * each other at 6. The fleet moves at speed 1 until it reaches target.
 * Note that no other cars meet these fleets before the destination, so the
 * answer is 3.
 * 
 * 
 * Example 2:
 * 
 * 
 * Input: target = 10, position = [3], speed = [3]
 * Output: 1
 * Explanation: There is only one car, hence there is only one fleet.
 * 
 * 
 * Example 3:
 * 
 * 
 * Input: target = 100, position = [0,2,4], speed = [4,2,1]
 * Output: 1
 * Explanation:
 * The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting
 * each other at 4. The fleet moves at speed 2.
 * Then, the fleet (speed 2) and the car starting at 4 (speed 1) become one
 * fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches
 * target.
 * 
 * 
 * 
 * Constraints:
 * 
 * 
 * n == position.length == speed.length
 * 1 <= n <= 10^5
 * 0 < target <= 10^6
 * 0 <= position[i] < target
 * All the values of position are unique.
 * 0 < speed[i] <= 10^6
 * 
 * 
 */

// @lc code=start
class Solution {
public:

    void swap(vector<int> &v,int i,int j)
    {
        int temp=v[i];
        v[i]=v[j];
        v[j]=temp;
    }


    void heapify(vector<int> &position,vector<int> &speed,int i,int s)
    {
        int left=i*2+1;
        int right=i*2+2;

        int maxm;

        if(left<s && position[left]>position[i])
                maxm=left;
        else
                maxm=i;
        
        if(right<s && position[right]>position[maxm])
                maxm=right;
        
        if(i!=maxm)
        {
            swap(position,i,maxm);
            swap(speed,i,maxm);
            heapify(position,speed,maxm,s);
        }
    }

    void buildheap(vector<int> &position,vector<int> &speed,int s)
    {
        for(int i=s/2;i>-1;i--)
        {
            heapify(position,speed,i,s);
        }
    }

    void heapsort(vector<int> &position,vector<int> &speed,int s)
    {
        buildheap(position,speed,s);

        for(int i=s-1;i>=0;i--)
        {
            swap(position,0,i);
            swap(speed,0,i);
            heapify(position,speed,0,i);

        }
    }

    float time(int pos,int spd,int target)
    {
        return ((target-pos)/((float)spd));
    }
    int carFleet(int target, vector<int>& position, vector<int>& speed) {
            int s=position.size();

            //first sort the cars according to position
            heapsort(position,speed,s);   

   
            int total_fleets=1;
            //now calculate the time taken by last car as it will definately make one fleet
            float total_time=time(position[s-1],speed[s-1],target);
            for(int i=s-2;i>-1;i--)
            {   
               //now check from backward if any car takes more time
               //than the car with maximum time then it will make its own fleet
               // hence update the fleet otherwise dont do anything as that car will be getting merged 
               // with the car whose time to reach the target is more that the current car 
              if(time(position[i],speed[i],target)>total_time)
              {
                  total_fleets+=1;
                  total_time=time(position[i],speed[i],target);
              }     
               

            }
            return total_fleets;
    }
};
// @lc code=end

